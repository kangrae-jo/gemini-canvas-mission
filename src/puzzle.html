<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŠ¬ë¼ì´ë”© í¼ì¦ ê²Œì„</title>
    <!-- Tailwind CSSë¥¼ ì‚¬ìš©í•˜ì—¬ UI ìŠ¤íƒ€ì¼ë§ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* í¼ì¦ ë³´ë“œ ì˜ì—­ì´ í„°ì¹˜ë  ë•Œ í˜ì´ì§€ ìŠ¤í¬ë¡¤ ë°©ì§€ */
        #puzzleContainer {
            touch-action: none;
            user-select: none;
        }
        
        /* íƒ€ì¼ ë‚´ë¶€ ê·¸ë¦¼ì ë° ë¶€ë“œëŸ¬ìš´ ì´ë™ íš¨ê³¼ */
        .puzzle-tile {
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.4);
            background-color: #374151; /* ë¹ˆ íƒ€ì¼ ë°°ê²½ìƒ‰ (ì´ë¯¸ì§€ ë¡œë“œ ì „) */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4 text-gray-800 font-sans">

    <div class="bg-white p-6 rounded-2xl shadow-xl w-full max-w-4xl">
        <h1 class="text-3xl font-extrabold text-center text-gray-900 mb-2">ìŠ¬ë¼ì´ë”© í¼ì¦</h1>
        <p class="text-center text-gray-500 mb-6 text-sm">íƒ€ì¼ì„ í´ë¦­í•˜ì—¬ ê·¸ë¦¼ì„ ì™„ì„±í•´ë³´ì„¸ìš”!</p>
        
        <!-- ì»¨íŠ¸ë¡¤ íŒ¨ë„ -->
        <div class="space-y-4 mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
            <!-- í¼ì¦ í¬ê¸° ì„ íƒ -->
            <div>
                <label class="block text-sm font-semibold text-gray-700 mb-1">í¼ì¦ ë‚œì´ë„ (í¬ê¸°)</label>
                <select id="sizeSelect" class="w-full rounded-lg border-gray-300 shadow-sm p-2.5 bg-white border outline-none focus:ring-2 focus:ring-blue-500 transition">
                    <option value="3">3 x 3 (ì‰¬ì›€)</option>
                    <option value="4">4 x 4 (ë³´í†µ)</option>
                    <option value="5">5 x 5 (ì–´ë ¤ì›€)</option>
                </select>
            </div>

            <!-- ì´ë¯¸ì§€ ì„ íƒ -->
            <div>
                <label class="block text-sm font-semibold text-gray-700 mb-1">í¼ì¦ ì´ë¯¸ì§€</label>
                <select id="imageSelect" class="w-full rounded-lg border-gray-300 shadow-sm p-2.5 bg-white border outline-none focus:ring-2 focus:ring-blue-500 transition mb-2">
                    <option value="default1">ê¸°ë³¸ ì‚¬ì§„ 1 (ì•„ë¦„ë‹¤ìš´ ìì—°)</option>
                    <option value="default2">ê¸°ë³¸ ì‚¬ì§„ 2 (ì•¼ê²½ ë„ì‹œ)</option>
                    <option value="default3">ê¸°ë³¸ ì‚¬ì§„ 3 (ê·€ì—¬ìš´ ê°•ì•„ì§€)</option>
                    <option value="custom">ë‚´ ì‚¬ì§„ìœ¼ë¡œ í•˜ê¸°...</option>
                </select>
                <!-- ì‚¬ìš©ì ì§€ì • ì‚¬ì§„ ì—…ë¡œë“œ (ê¸°ë³¸ ìˆ¨ê¹€) -->
                <input type="file" id="customFileInput" accept="image/*" class="hidden w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-100 file:text-blue-700 hover:file:bg-blue-200 cursor-pointer transition">
            </div>

            <!-- ë‚œì´ë„ ì¡°ì ˆ ë³´ì¡° (ìˆ«ì íŒíŠ¸) -->
            <div class="flex items-center">
                <input type="checkbox" id="hintToggle" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500" checked>
                <label for="hintToggle" class="ml-2 text-sm font-semibold text-gray-700 cursor-pointer">íƒ€ì¼ì— ìˆ«ì íŒíŠ¸ í‘œì‹œ</label>
            </div>

            <!-- ì‹œì‘ ë²„íŠ¼ -->
            <button id="startBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition shadow-md active:scale-95">
                ê²Œì„ ë‹¤ì‹œ ì‹œì‘
            </button>
        </div>

        <!-- ê²Œì„ ì˜ì—­ (ì›ë³¸ ì‚¬ì§„ + í¼ì¦ ë³´ë“œ) -->
        <div class="flex flex-col md:flex-row gap-6 md:gap-10 items-center justify-center">
            
            <!-- ì›ë³¸ ì‚¬ì§„ ì˜ì—­ (ì™¼ìª½) -->
            <div class="flex flex-col items-center w-2/5 max-w-[160px] md:max-w-[220px] shrink-0">
                <span class="text-xs md:text-sm font-bold text-gray-700 mb-2 bg-gray-200 px-3 py-1 rounded-full shadow-sm">ì›ë³¸ ì‚¬ì§„</span>
                <img id="referenceImg" src="" alt="ì›ë³¸ ì‚¬ì§„" class="w-full aspect-square rounded-xl shadow-md border-2 border-gray-300">
            </div>

            <!-- ê²Œì„ ë³´ë“œ ì»¨í…Œì´ë„ˆ (ì˜¤ë¥¸ìª½) -->
            <div class="relative w-full max-w-sm md:max-w-lg transition-all duration-300" id="puzzleContainer" style="aspect-ratio: 4/3;">
                <!-- ì‹¤ì œ í¼ì¦ ì¡°ê°ë“¤ì´ ë°°ì¹˜ë˜ëŠ” ê³³ -->
                <div id="puzzleBoard" class="absolute inset-0 w-full h-full"></div>
                
                <!-- ì™„ë£Œ ì¶•í•˜ ëª¨ë‹¬ (ì´ˆê¸°ì—ëŠ” ìˆ¨ê¹€) -->
                <div id="winModal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex-col items-center justify-center text-white z-[100] transition-opacity">
                    <div class="bg-white text-gray-900 p-6 rounded-2xl shadow-2xl text-center mx-4 transform scale-100">
                        <div class="text-4xl mb-2">ğŸ‰</div>
                        <h2 class="text-2xl font-bold mb-2">í¼ì¦ ì™„ì„±!</h2>
                        <p class="text-gray-600 mb-6 text-sm">ì¶•í•˜í•©ë‹ˆë‹¤! ì™„ë²½í•˜ê²Œ ë§ì¶”ì…¨ìŠµë‹ˆë‹¤.</p>
                        <!-- ì—ëŸ¬ì˜ ì›ì¸ì´ì—ˆë˜ ë²„íŠ¼ ìš”ì†Œë¥¼ ë³µêµ¬í–ˆìŠµë‹ˆë‹¤ -->
                        <button id="restartBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2.5 px-8 rounded-full transition shadow-lg active:scale-95 w-full">
                            ë‹¤ì‹œ í•˜ê¸°
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- ë³€ìˆ˜ ë° DOM ìš”ì†Œ ì´ˆê¸°í™” ---
            const defaultImages = [
                'https://images.unsplash.com/photo-1472214103451-9374bd1c798e?auto=format&fit=crop&w=600&q=80', // ìì—°
                'https://images.unsplash.com/photo-1449844908441-8829872d2607?auto=format&fit=crop&w=600&q=80', // ë„ì‹œ
                'https://images.unsplash.com/photo-1543852786-1cf6624b9987?auto=format&fit=crop&w=600&q=80'  // ê°•ì•„ì§€
            ];

            let currentImgUrl = defaultImages[0];
            let gridSize = 3;
            let tiles = [];
            let isPlaying = false;
            let emptySlotIndex = gridSize * gridSize; // ì¶”ê°€ëœ ì—¬ë¶„ ìŠ¬ë¡¯ ì¸ë±ìŠ¤

            const board = document.getElementById('puzzleBoard');
            const winModal = document.getElementById('winModal');
            const referenceImg = document.getElementById('referenceImg');
            const sizeSelect = document.getElementById('sizeSelect');
            const imageSelect = document.getElementById('imageSelect');
            const customFileInput = document.getElementById('customFileInput');
            const hintToggle = document.getElementById('hintToggle');
            const startBtn = document.getElementById('startBtn');
            const restartBtn = document.getElementById('restartBtn');

            // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---
            
            // ìˆ«ì íŒíŠ¸ í† ê¸€
            hintToggle.addEventListener('change', (e) => {
                const hintEls = document.querySelectorAll('.tile-hint');
                hintEls.forEach(el => {
                    el.style.display = e.target.checked ? 'block' : 'none';
                });
            });

            // í¬ê¸° ë³€ê²½ ì‹œ ì¬ì‹œì‘
            sizeSelect.addEventListener('change', () => {
                gridSize = parseInt(sizeSelect.value);
                initGame();
            });

            // ì´ë¯¸ì§€ ì†ŒìŠ¤ ë³€ê²½
            imageSelect.addEventListener('change', (e) => {
                if (e.target.value === 'custom') {
                    customFileInput.classList.remove('hidden');
                } else {
                    customFileInput.classList.add('hidden');
                    const idx = parseInt(e.target.value.replace('default', '')) - 1;
                    currentImgUrl = defaultImages[idx];
                    initGame();
                }
            });

            // ì‚¬ìš©ì ì‚¬ì§„ ì—…ë¡œë“œ
            customFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        currentImgUrl = event.target.result;
                        initGame();
                    };
                    reader.readAsDataURL(file);
                }
            });

            // ì‹œì‘ / ë‹¤ì‹œì‹œì‘ ë²„íŠ¼
            startBtn.addEventListener('click', initGame);
            restartBtn.addEventListener('click', initGame);

            // --- ê²Œì„ ë¡œì§ ---

            // ì¢Œí‘œ ê³„ì‚° í—¬í¼ í•¨ìˆ˜ (ì¶”ê°€ëœ ë¹ˆì¹¸ ê³ ë ¤)
            function getCoords(index) {
                // ì¶”ê°€ëœ ìŠ¬ë¡¯ì€ í•­ìƒ (gridSize - 1)í–‰, (gridSize)ì—´ì— ìœ„ì¹˜
                if (index === gridSize * gridSize) {
                    return { row: gridSize - 1, col: gridSize };
                }
                return {
                    row: Math.floor(index / gridSize),
                    col: index % gridSize
                };
            }

            // ê²Œì„ ì´ˆê¸°í™”
            function initGame() {
                isPlaying = false;
                board.innerHTML = '';
                winModal.classList.add('hidden');
                winModal.classList.remove('flex');
                
                // ì›ë³¸ ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°ì— í˜„ì¬ ì´ë¯¸ì§€ ì ìš©
                referenceImg.src = currentImgUrl;
                
                // ì»¨í…Œì´ë„ˆ ë¹„ìœ¨ ì—…ë°ì´íŠ¸ (N+1 ê°€ë¡œ ë„ˆë¹„ í™•ë³´)
                const container = document.getElementById('puzzleContainer');
                container.style.aspectRatio = `${gridSize + 1} / ${gridSize}`;
                
                // === ë³´ë“œ ë°°ê²½ ë° í…Œë‘ë¦¬ UI ë™ì  ìƒì„± (SVG í™œìš©í•˜ì—¬ ëŠì–´ì§ ì—†ëŠ” í•˜ë‚˜ì˜ í˜•íƒœë¡œ êµ¬í˜„) ===
                const svgNS = "http://www.w3.org/2000/svg";
                const pathD = `M 0 0 L ${gridSize} 0 L ${gridSize} ${gridSize - 1} L ${gridSize + 1} ${gridSize - 1} L ${gridSize + 1} ${gridSize} L 0 ${gridSize} Z`;

                // 1. ë°°ê²½ SVG (z-0)
                const svgBg = document.createElementNS(svgNS, "svg");
                svgBg.setAttribute("class", "absolute inset-0 w-full h-full z-0");
                svgBg.setAttribute("viewBox", `0 0 ${gridSize + 1} ${gridSize}`);
                const pathFill = document.createElementNS(svgNS, "path");
                pathFill.setAttribute("d", pathD);
                pathFill.setAttribute("fill", "#d1d5db"); // Tailwind gray-300
                svgBg.appendChild(pathFill);
                board.appendChild(svgBg);

                // 2. í…Œë‘ë¦¬ SVG (z-20)
                const svgBorder = document.createElementNS(svgNS, "svg");
                svgBorder.setAttribute("class", "absolute inset-0 w-full h-full pointer-events-none z-20 overflow-visible");
                svgBorder.setAttribute("viewBox", `0 0 ${gridSize + 1} ${gridSize}`);
                const pathStroke = document.createElementNS(svgNS, "path");
                pathStroke.setAttribute("d", pathD);
                pathStroke.setAttribute("fill", "none");
                pathStroke.setAttribute("stroke", "#1f2937"); // Tailwind gray-800
                pathStroke.setAttribute("stroke-width", "4"); 
                pathStroke.setAttribute("vector-effect", "non-scaling-stroke");
                pathStroke.setAttribute("stroke-linejoin", "round");
                svgBorder.appendChild(pathStroke);
                board.appendChild(svgBorder);

                tiles = [];
                const tileCount = gridSize * gridSize;
                emptySlotIndex = tileCount; // ì´ˆê¸° ë¹ˆì¹¸ ìœ„ì¹˜ë¥¼ ìš°ì¸¡ í•˜ë‹¨ ì—¬ë¶„ ìŠ¬ë¡¯ìœ¼ë¡œ ì„¤ì •
                
                // íƒ€ì¼ ìƒì„± (ë¹„ì–´ìˆëŠ” ì¡°ê° ì—†ì´ 100% ì´ë¯¸ì§€ ì‚¬ìš©)
                for (let i = 0; i < tileCount; i++) {
                    const tile = document.createElement('div');
                    
                    // z-10ìœ¼ë¡œ ì„¤ì •í•˜ì—¬ ë°°ê²½(z-0)ê³¼ ê²‰í…Œë‘ë¦¬(z-20) ì‚¬ì´ì—ì„œ ìŠ¬ë¼ì´ë”©ë˜ë„ë¡ í•¨
                    tile.className = 'puzzle-tile absolute bg-no-repeat transition-transform cursor-pointer box-border border-2 border-white/30 rounded-sm shadow-sm z-10';
                    
                    // ë„ˆë¹„ ë° ë†’ì´ ê³„ì‚°
                    tile.style.width = `${100 / (gridSize + 1)}%`;
                    tile.style.height = `${100 / gridSize}%`;
                    
                    // ë°°ê²½ ì´ë¯¸ì§€ ë° í¬ê¸°
                    tile.style.backgroundImage = `url(${currentImgUrl})`;
                    tile.style.backgroundSize = `${gridSize * 100}% ${gridSize * 100}%`;
                    
                    // ë°°ê²½ ìœ„ì¹˜ (ì¡°ê°ì´ ì›ë³¸ì—ì„œ ë‹´ë‹¹í•  ìœ„ì¹˜)
                    const origRow = Math.floor(i / gridSize);
                    const origCol = i % gridSize;
                    tile.style.backgroundPosition = `${(origCol / (gridSize - 1)) * 100}% ${(origRow / (gridSize - 1)) * 100}%`;
                    
                    // ìˆ«ì íŒíŠ¸ ìš”ì†Œ
                    const hint = document.createElement('div');
                    hint.className = 'tile-hint absolute top-1 left-1 bg-black bg-opacity-60 text-white text-xs md:text-sm px-1.5 py-0.5 rounded font-bold pointer-events-none';
                    hint.textContent = i + 1;
                    hint.style.display = hintToggle.checked ? 'block' : 'none';
                    tile.appendChild(hint);

                    const tileObj = {
                        el: tile,
                        originalIndex: i,
                        currentIndex: i // ì´ˆê¸°ì—ëŠ” ì •ë‹µ ìœ„ì¹˜ì— ë°°ì¹˜
                    };
                    
                    // ëª¨ë“  íƒ€ì¼ì— í´ë¦­ ì´ë²¤íŠ¸ í™œì„±í™”
                    tile.addEventListener('click', () => handleTileClick(tileObj));
                    
                    tiles.push(tileObj);
                    board.appendChild(tile);
                }
                
                // í¼ì¦ ì„ê¸° ë° ë°°ì¹˜ ë Œë”ë§
                shuffleTiles();
                renderAll();
                
                // ë Œë”ë§ í›„ íŠ¸ëœì§€ì…˜ ì• ë‹ˆë©”ì´ì…˜ í™œì„±í™”
                requestAnimationFrame(() => {
                    setTimeout(() => {
                        tiles.forEach(t => t.el.classList.add('duration-200', 'ease-in-out'));
                        isPlaying = true;
                    }, 50);
                });
            }

            // ëª¨ë“  íƒ€ì¼ì˜ ìœ„ì¹˜ë¥¼ CSS transformìœ¼ë¡œ ë Œë”ë§
            function renderAll() {
                tiles.forEach(t => {
                    const coords = getCoords(t.currentIndex);
                    t.el.style.transform = `translate(${coords.col * 100}%, ${coords.row * 100}%)`;
                });
            }

            // í¼ì¦ ë¬´ì‘ìœ„ ì„ê¸° ì•Œê³ ë¦¬ì¦˜
            function shuffleTiles() {
                let prevIndex = -1;
                const shuffleMoves = gridSize * gridSize * 25; 
                
                for (let i = 0; i < shuffleMoves; i++) {
                    const emptyCoords = getCoords(emptySlotIndex);
                    
                    // í˜„ì¬ ë¹ˆì¹¸(emptySlotIndex)ì— ì¸ì ‘í•´ ìˆëŠ” íƒ€ì¼ ì°¾ê¸°
                    const neighbors = tiles.filter(t => {
                        const tCoords = getCoords(t.currentIndex);
                        return Math.abs(tCoords.row - emptyCoords.row) + Math.abs(tCoords.col - emptyCoords.col) === 1;
                    });
                    
                    // ì§ì „ì— ì›€ì§ì˜€ë˜ íƒ€ì¼ì€ ì œì™¸í•˜ì—¬ ì œìë¦¬ê±¸ìŒ ë°©ì§€
                    const validNeighbors = neighbors.filter(n => n.currentIndex !== prevIndex);
                    
                    const tileToMove = validNeighbors.length > 0 
                        ? validNeighbors[Math.floor(Math.random() * validNeighbors.length)] 
                        : neighbors[0];
                    
                    prevIndex = emptySlotIndex;
                    
                    // ìë¦¬ ìŠ¤ì™‘
                    const temp = tileToMove.currentIndex;
                    tileToMove.currentIndex = emptySlotIndex;
                    emptySlotIndex = temp;
                }

                // ë¬´ì‘ìœ„ ì„ê¸° í›„, ì‹œì‘ ì‹œ ë¹ˆì¹¸ì„ ìš°ì¸¡ í•˜ë‹¨ì˜ "ë³´ì¡° ì£¼ì°¨ì¥" ì˜ì—­ì— ê°•ì œ ê·€í™˜ì‹œí‚´
                while (emptySlotIndex !== gridSize * gridSize) {
                    const emptyCoords = getCoords(emptySlotIndex);
                    let nextRow = emptyCoords.row;
                    let nextCol = emptyCoords.col;

                    // ë¹ˆì¹¸ì´ ëª©ì ì§€ë¡œ ëŒì•„ê°€ê¸° ìœ„í•œ ë°©í–¥ ìš°ì„ ìˆœìœ„ ê³„ì‚°
                    if (emptyCoords.col < gridSize - 1) {
                        nextCol++;
                    } else if (emptyCoords.row < gridSize - 1) {
                        nextRow++;
                    } else {
                        nextCol++; // ë§ˆì§€ë§‰ìœ¼ë¡œ ë³¸ì²´ì—ì„œ ìš°ì¸¡ ì£¼ì°¨ì¥ìœ¼ë¡œ í•œ ì¹¸ ì´ë™
                    }

                    // ì´ë™í•  ì¹¸ì˜ index ê³„ì‚°
                    let nextIndex;
                    if (nextRow === gridSize - 1 && nextCol === gridSize) {
                        nextIndex = gridSize * gridSize;
                    } else {
                        nextIndex = nextRow * gridSize + nextCol;
                    }

                    // í•´ë‹¹ indexì— ìˆëŠ” ì¡°ê°ê³¼ ìŠ¤ì™‘
                    const tileToMove = tiles.find(t => t.currentIndex === nextIndex);
                    tileToMove.currentIndex = emptySlotIndex;
                    emptySlotIndex = nextIndex;
                }
            }

            // íƒ€ì¼ í´ë¦­(í„°ì¹˜) í•¸ë“¤ëŸ¬
            function handleTileClick(tileObj) {
                if (!isPlaying) return;
                
                const tileCoords = getCoords(tileObj.currentIndex);
                const emptyCoords = getCoords(emptySlotIndex);
                
                // ë¹ˆì¹¸(ê°€ìƒì˜ ìŠ¬ë¡¯)ê³¼ ë‚´ê°€ í´ë¦­í•œ íƒ€ì¼ì´ ì¸ì ‘í•œì§€ í™•ì¸
                const isAdjacent = Math.abs(tileCoords.row - emptyCoords.row) + Math.abs(tileCoords.col - emptyCoords.col) === 1;
                
                if (isAdjacent) {
                    // ìœ„ì¹˜ êµí™˜
                    const temp = tileObj.currentIndex;
                    tileObj.currentIndex = emptySlotIndex;
                    emptySlotIndex = temp;
                    
                    renderAll();
                    checkWin();
                }
            }

            // ìŠ¹ë¦¬ ì²´í¬ ë¡œì§
            function checkWin() {
                if (!isPlaying) return;
                
                // 'ëª¨ë“ ' íƒ€ì¼ì´ ìì‹ ì˜ ì›ë˜ ìë¦¬ì— ë„ë‹¬í–ˆëŠ”ì§€ í™•ì¸
                const isWin = tiles.every(t => t.currentIndex === t.originalIndex);
                
                if (isWin) {
                    isPlaying = false;
                    
                    // ì´ì „ì²˜ëŸ¼ ë¹ˆì¹¸ì„ ê°•ì œë¡œ ì±„ìš¸ í•„ìš” ì—†ìŒ (ì´ë¯¸ ì‚¬ì§„ 100% ì±„ì›Œì§)
                    setTimeout(() => {
                        winModal.classList.remove('hidden');
                        winModal.classList.add('flex');
                    }, 300);
                }
            }

            // ì´ˆê¸° ì‹¤í–‰
            initGame();
        });
    </script>
</body>
</html>
